//
//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
//

#import "TSGroupThread.h"
#import "TSAttachmentStream.h"
#import <SignalCoreKit/NSData+OWS.h>
#import <SignalServiceKit/SignalServiceKit-Swift.h>
#import <SignalServiceKit/TSAccountManager.h>

NS_ASSUME_NONNULL_BEGIN

NSString *const TSGroupThreadAvatarChangedNotification = @"TSGroupThreadAvatarChangedNotification";
NSString *const TSGroupThread_NotificationKey_UniqueId = @"TSGroupThread_NotificationKey_UniqueId";

@interface TSGroupThread ()

@property (nonatomic) TSGroupModel *groupModel;

@end

#pragma mark -

@implementation TSGroupThread

#define TSGroupThreadPrefix @"g"

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
           conversationColorName:(ConversationColorName)conversationColorName
                    creationDate:(nullable NSDate *)creationDate
                      isArchived:(BOOL)isArchived
                  isMarkedUnread:(BOOL)isMarkedUnread
            lastInteractionRowId:(int64_t)lastInteractionRowId
               lastVisibleSortId:(uint64_t)lastVisibleSortId
lastVisibleSortIdOnScreenPercentage:(double)lastVisibleSortIdOnScreenPercentage
         mentionNotificationMode:(TSThreadMentionNotificationMode)mentionNotificationMode
                    messageDraft:(nullable NSString *)messageDraft
          messageDraftBodyRanges:(nullable MessageBodyRanges *)messageDraftBodyRanges
                  mutedUntilDate:(nullable NSDate *)mutedUntilDate
           shouldThreadBeVisible:(BOOL)shouldThreadBeVisible
                      groupModel:(TSGroupModel *)groupModel
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
             conversationColorName:conversationColorName
                      creationDate:creationDate
                        isArchived:isArchived
                    isMarkedUnread:isMarkedUnread
              lastInteractionRowId:lastInteractionRowId
                 lastVisibleSortId:lastVisibleSortId
lastVisibleSortIdOnScreenPercentage:lastVisibleSortIdOnScreenPercentage
           mentionNotificationMode:mentionNotificationMode
                      messageDraft:messageDraft
            messageDraftBodyRanges:messageDraftBodyRanges
                    mutedUntilDate:mutedUntilDate
             shouldThreadBeVisible:shouldThreadBeVisible];

    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (MessageSenderJobQueue *)messageSenderJobQueue
{
    return SSKEnvironment.shared.messageSenderJobQueue;
}

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    return [super initWithCoder:coder];
}

- (instancetype)initWithGroupModelPrivate:(TSGroupModel *)groupModel
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);
    for (SignalServiceAddress *address in groupModel.groupMembers) {
        OWSAssertDebug(address.isValid);
    }

    NSString *uniqueIdentifier = [[self class] threadIdFromGroupId:groupModel.groupId];
    self = [super initWithUniqueId:uniqueIdentifier];
    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

+ (nullable instancetype)fetchWithGroupId:(NSData *)groupId transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(groupId.length > 0);

    NSString *uniqueId = [self threadIdFromGroupId:groupId];
    return [TSGroupThread anyFetchGroupThreadWithUniqueId:uniqueId transaction:transaction];
}

+ (NSString *)threadIdFromGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    return [TSGroupThreadPrefix stringByAppendingString:[groupId base64EncodedString]];
}

+ (NSData *)groupIdFromThreadId:(NSString *)threadId
{
    OWSAssertDebug(threadId.length > 0);

    return [NSData dataFromBase64String:[threadId substringWithRange:NSMakeRange(1, threadId.length - 1)]];
}

- (NSArray<SignalServiceAddress *> *)recipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *groupMembers = [self.groupModel.groupMembers mutableCopy];
    if (groupMembers == nil) {
        return @[];
    }

    [groupMembers removeObject:TSAccountManager.localAddress];

    return [groupMembers copy];
}

// @returns all threads to which the recipient is a member.
//
// @note If this becomes a hotspot we can extract into a YapDB View.
// As is, the number of groups should be small (dozens, *maybe* hundreds), and we only enumerate them upon SN changes.
+ (NSArray<TSGroupThread *> *)groupThreadsWithAddress:(SignalServiceAddress *)address
                                          transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(address.isValid);
    OWSAssertDebug(transaction);

    NSMutableArray<TSGroupThread *> *groupThreads = [NSMutableArray new];

    [TSThread anyEnumerateWithTransaction:transaction
                                  batched:YES
                                    block:^(TSThread *thread, BOOL *stop) {
                                        if ([thread isKindOfClass:[TSGroupThread class]]) {
                                            TSGroupThread *groupThread = (TSGroupThread *)thread;
                                            if ([groupThread.groupModel.groupMembers containsObject:address]) {
                                                [groupThreads addObject:groupThread];
                                            }
                                        }
                                    }];

    return [groupThreads copy];
}

- (BOOL)isGroupThread
{
    return true;
}

- (BOOL)isGroupV1Thread
{
    return self.groupModel.groupsVersion == GroupsVersionV1;
}

- (BOOL)isGroupV2Thread
{
    return self.groupModel.groupsVersion == GroupsVersionV2;
}

- (NSString *)groupNameOrDefault
{
    return self.groupModel.groupNameOrDefault;
}

+ (NSString *)defaultGroupName
{
    return NSLocalizedString(@"NEW_GROUP_DEFAULT_TITLE", @"");
}

- (void)updateWithGroupModel:(TSGroupModel *)groupModel transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(transaction);
    OWSAssertDebug(groupModel.groupsVersion == self.groupModel.groupsVersion);

    BOOL didAvatarChange = ![NSObject isNullableObject:groupModel.groupAvatarData
                                               equalTo:self.groupModel.groupAvatarData];

    [self
        anyUpdateGroupThreadWithTransaction:transaction
                                      block:^(TSGroupThread *thread) {
                                          if ([thread.groupModel isKindOfClass:TSGroupModelV2.class] ||
                                              [groupModel isKindOfClass:TSGroupModelV2.class]) {
                                              if (![thread.groupModel isKindOfClass:TSGroupModelV2.class]
                                                  || ![groupModel isKindOfClass:TSGroupModelV2.class]) {
                                                  OWSFailDebug(@"Invalid group model.");
                                              } else {
                                                  TSGroupModelV2 *oldGroupModelV2 = (TSGroupModelV2 *)thread.groupModel;
                                                  TSGroupModelV2 *newGroupModelV2 = (TSGroupModelV2 *)groupModel;
                                                  OWSAssertDebug(oldGroupModelV2.revision <= newGroupModelV2.revision);
                                              }
                                          }

                                          thread.groupModel = [groupModel copy];
                                      }];

    if (didAvatarChange) {
        [transaction addAsyncCompletion:^{
            [self fireAvatarChangedNotification];
        }];
    }
}

- (void)fireAvatarChangedNotification
{
    OWSAssertIsOnMainThread();

    NSDictionary *userInfo = @{ TSGroupThread_NotificationKey_UniqueId : self.uniqueId };

    [[NSNotificationCenter defaultCenter] postNotificationName:TSGroupThreadAvatarChangedNotification
                                                        object:self.uniqueId
                                                      userInfo:userInfo];
}

+ (ConversationColorName)defaultConversationColorNameForGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    return [self.class stableColorNameForNewConversationWithString:[self threadIdFromGroupId:groupId]];
}

- (void)anyWillRemoveWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    if (self.isGroupV2Thread) {
        OWSFailDebug(@"In normal usage we should only soft delete v2 groups.");
    }
    [super anyWillRemoveWithTransaction:transaction];
}

@end

NS_ASSUME_NONNULL_END
